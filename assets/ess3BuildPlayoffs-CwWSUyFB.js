async function m(n){const i=await fetch(n);if(!i.ok)throw new Error(`Failed to load playoffs file: ${n}`);return await i.json()}function d(n){return n.rounds.flatMap(i=>i.series.map(t=>{const r={};t.participants.forEach(s=>{r[s]=0}),t.games.forEach(s=>{s.winner&&r[s.winner]!==void 0&&r[s.winner]++});const e=Math.ceil(t.bestOf/2);let a;for(const s of t.participants)if(r[s]>=e){a=s;break}const o={...t,winsByTeam:r,winner:a};return{round:i.name,tag:i.tag,series:o}}))}function f(n){const i=n.series.games.map(t=>t.scheduledAt).filter(t=>typeof t=="string").map(t=>new Date(t)).filter(t=>!isNaN(t.getTime()));return i.length?new Date(Math.min(...i.map(t=>t.getTime()))):null}function u(n){return!!n.series.winner}function g(n,i=7200*1e3){if(u(n))return!1;const t=f(n);if(!t)return!1;const r=Date.now(),e=t.getTime();return r>=e&&r<=e+i}function w(n){const i=Date.now(),t=n.map((e,a)=>({entry:e,index:a,start:f(e)})).filter(e=>e.start&&e.start.getTime()>i).sort((e,a)=>e.start.getTime()-a.start.getTime());if(t.length)return t[0].index;const r=n.map((e,a)=>({entry:e,index:a,start:f(e)})).filter(e=>!e.entry.series.winner);return r.length?(r.sort((e,a)=>{var c,l;const o=((c=e.start)==null?void 0:c.getTime())??0;return(((l=a.start)==null?void 0:l.getTime())??0)-o}),r[0].index):Math.max(n.length-1,0)}export{w as a,g as b,d as f,f as g,u as i,m as l};
