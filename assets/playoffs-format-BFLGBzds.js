function I(t,o,n){const r={};return t.forEach(s=>{const l=s.wins+s.losses,h=o-l,c=s.wins,m=s.wins+h;if(t.filter(f=>{if(f.teamId===s.teamId)return!1;const g=o-(f.wins+f.losses);return f.wins+g>c}).length<n){r[s.teamId]="yes";return}if(t.filter(f=>f.teamId===s.teamId?!1:f.wins>m).length>=n){r[s.teamId]="no";return}r[s.teamId]="maybe"}),r}function M(t,o,n,r,s=[],l=[]){const{matches:h,individualMaxGamesPlayed:c,playoffSlots:m}=t,p={};Object.values(o).forEach(e=>{p[e.id]=e});const a={};Object.entries(n).forEach(([e,i])=>{const w=p[e];w&&(a[e]={teamId:e,teamName:w.displayName,wins:0,losses:0,squares:0,lines:0,h2h:{},players:i.players})}),h.forEach(e=>{const[i,w]=e.participants,u=e.winner,d=i.id===u?w.id:i.id;!a[u]||!a[d]||(a[u].wins++,a[d].losses++,a[i.id].squares+=i.score,a[w.id].squares+=w.score,e.method==="Bingo"&&a[u].lines++,a[u].h2h[d]=!0)}),s.forEach(e=>{!a[e.winner]||!a[e.loser]||(a[e.winner].wins++,a[e.loser].losses++,a[e.winner].squares+=e.squaresAwarded,e.countsAsLine&&a[e.winner].lines++,a[e.winner].h2h[e.loser]=!0)}),l.forEach(e=>{a[e.receiver]&&(a[e.receiver].lines+=e.linesAwarded)});const f=Object.values(a).map(e=>{const i=e.wins+e.losses,w=i>0?(e.wins/i*100).toFixed(1):"0.0",u=r[e.players[0]],d=r[e.players[1]];return{teamId:e.teamId,teamName:e.teamName,wins:e.wins,losses:e.losses,record:`${e.wins}-${e.losses}`,gamesPlayed:i,WR:w,squares:e.squares,lines:e.lines,h2h:e.h2h,Playoffs:"maybe",player1:u?{name:u.displayName,nickname:u.nickname,twitch:u.twitch,profilePic:u.profilePic}:null,player2:d?{name:d.displayName,nickname:d.nickname,twitch:d.twitch,profilePic:d.profilePic}:null}});f.sort((e,i)=>i.wins!==e.wins?i.wins-e.wins:e.losses!==i.losses?e.losses-i.losses:e.h2h[i.teamId]?-1:i.h2h[e.teamId]?1:i.lines!==e.lines?i.lines-e.lines:i.squares!==e.squares?i.squares-e.squares:0);const g=I(f,c,m);return f.forEach(e=>{e.Playoffs=g[e.teamId]}),f}async function q(t){const o=await fetch(t);if(!o.ok)throw new Error(`Failed to load playoffs file: ${t}`);return await o.json()}function P(t){return t.rounds.flatMap(o=>o.series.map(n=>{const r={};n.participants.forEach(c=>{r[c]=0}),n.games.forEach(c=>{c.winner&&r[c.winner]!==void 0&&r[c.winner]++});const s=Math.ceil(n.bestOf/2);let l;for(const c of n.participants)if(r[c]>=s){l=c;break}const h={...n,winsByTeam:r,winner:l};return{round:o.name,tag:o.tag,series:h}}))}function y(t){const o=t.series.games.map(n=>n.scheduledAt).filter(n=>typeof n=="string").map(n=>new Date(n)).filter(n=>!isNaN(n.getTime()));return o.length?new Date(Math.min(...o.map(n=>n.getTime()))):null}function T(t){return!!t.series.winner}function v(t,o=7200*1e3){if(T(t))return!1;const n=y(t);if(!n)return!1;const r=Date.now(),s=n.getTime();return r>=s&&r<=s+o}function E(t){const o=Date.now(),n=t.map((s,l)=>({entry:s,index:l,start:y(s)})).filter(s=>s.start&&s.start.getTime()>o).sort((s,l)=>s.start.getTime()-l.start.getTime());if(n.length)return n[0].index;const r=t.map((s,l)=>({entry:s,index:l,start:y(s)})).filter(s=>!s.entry.series.winner);return r.length?(r.sort((s,l)=>{var m,p;const h=((m=s.start)==null?void 0:m.getTime())??0;return(((p=l.start)==null?void 0:p.getTime())??0)-h}),r[0].index):Math.max(t.length-1,0)}export{E as a,M as b,v as c,P as f,y as g,T as i,q as l};
